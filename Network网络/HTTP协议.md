# HTTP

## 请求头字段

**通用字段**

- Cache-Control：控制缓存行为 `no-cache/no-store/max-age=<seconds>`

**请求首部**

- Accept：能正确接收的媒体类型 

- Origin：源地址

- If-Modified-Since：本地资源未修改返回 304（比较时间）

- If-None-Match：本地资源未修改返回 304（比较标记）

- User-Agent：客户端信息

- Range：请求某个内容的一部分

- Referer：表示浏览器所访问的前一个页面

**响应首部**

- Age：资源在代理缓存中存在的时间

- ETag：资源标识

- Location：客户端重定向到某个 URL

**实体首部**

- Content-Length：request body 长度

- Content-Type：内容的媒体类型

- Expires：内容的过期时间

- Last_modified：内容的最后修改时间

## 请求体

**Post/Get请求区别**：

Get参数通过URL传递，Post则在request body，这导致有以下区别：

- Get参数有长度限制（浏览器限制url长度），Post没有

- Post相对Get安全性高一点，因为Get参数暴露在URL上

- Get只能使用URL编码（百分号编码），Post支持多种编码格式（URL，JSON，Form）

- Get请求会被历史记录保存，回退时会重发，受缓存机制控制；Post不会

总结：Get、Post只是Http规定的标准，语义区分应用，本质都是基于TCP的Http请求；

# HTTPS

是安全的HTTP版本。

在HTTP的基础上增加加密层来保障数据传输的安全性，HTTPS的工作原理是在传输数据前通过加密协议对通信进行加密（TLS协议，传输层之上应用层之下）；

## 加密

TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

**对称加密**：两边拥有相同的秘钥，两边都知道如何将密文加密解密。

**非对称加密**：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。

简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。

**加密算法**

对称加密：AES、ECDHE

非对称加密：RSA

哈希算法：SHA256（**哈希算法**用于生成数据的固定长度摘要，用于验证数据完整性和安全性，但不提供加密和解密功能。）

HTTPS的核心概念是结合对称加密和非对称加密，但在实际应用中，各种算法的使用是为了满足不同的安全需求：

- **密钥交换**：ECDHE使得双方可以安全地生成共享的对称密钥（密钥值）。
- **身份验证**：RSA用于验证服务器身份（证书），确保客户端连接的是合法服务器（公钥）。
- **数据加密**：AES256-GCM保护传输中的数据（密钥加密算法）。
- **数据完整性**：SHA384确保数据未被篡改。

## 数字证书

**DNS 劫持**

将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。

事实上 `HTTPS` 在上述 `结合对称和非对称加密` 的基础上，又添加了 `数字证书认证` 的步骤。其目的就是让服务器证明自己的身份。

**CA(`Certificate Authority`)**

服务器运营者需要向第三方认证机构获取授权，认证通过后 CA 会给服务器颁发 **数字证书**。

这个数字证书有两个作用：

1. 服务器向浏览器证明自己的身份。
2. 把公钥传给浏览器。

**认证过程**

浏览器拿到数字证书后，如何来对证书进行认证呢？

服务器返回它的 **数字证书**，这包含了服务器的公钥、服务器的域名、有效期，以及签发该证书的 CA 的签名信息。

**检查服务器证书**：

- 浏览器首先查看服务器证书的签名。
- 服务器证书是由某个 CA 签发的，中间 CA 会使用它的私钥对服务器证书内容生成的哈希值进行加密，从而产生该证书的签名。

**找到中间 CA 的公钥验证服务器证书**：

- 浏览器从服务器返回的证书链中找到相应的中间 CA 证书，**获取中间 CA 的公钥**。
- 浏览器使用中间 CA 的公钥解密服务器证书的签名，得到签名解密后的内容（哈希值）。
- 同时，浏览器也会对服务器证书内容**再次计算哈希值**。然后，将计算得到的哈希值与解密得到的哈希值对比。
- 如果两者匹配，说明服务器证书未被篡改。

# HTTP1.1/2

在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

在 HTTP/2 中引入了**多路复用**的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也间接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。

## 多路复用

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

**多路复用**，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

## 二进制传输

之前的 HTTP 版本中，我们是通过文本的方式传输数据。

HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

## Header 压缩

在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

## HTTP3

HTTP2 **多路复用** 的TCP等待重传问题；基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上；
