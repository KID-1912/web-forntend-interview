# 0.1 + 0.2 !== 0.3

JS 采用双精度版本（64位）存储数字， 64 位之外多余的会被裁剪掉，造成精度丢失；

很多十进制小数用二进制表示都是无限循环的；

**解决** 

```js
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
Math.round(num * 100) / 100; // 四舍五入指定位
```

ecimal.js或big.js，提供高精度的十进制运算；

# 垃圾回收机制

**老生代算法**：

标记清楚法和标记压缩法
